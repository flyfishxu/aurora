// AuroraLang Standard Library - Math
// Mathematical functions and constants

// Note: Constants will be added when language supports global constants
// For now, use functions or inline values
// PI = 3.141592653589793
// E = 2.718281828459045

// Absolute value for integers
fn absInt(x: int) -> int {
    if x < 0 {
        return -x
    }
    return x
}

// Absolute value for doubles
fn absDouble(x: double) -> double {
    if x < 0.0 {
        return -x
    }
    return x
}

// Minimum of two integers
fn minInt(a: int, b: int) -> int {
    if a < b {
        return a
    }
    return b
}

// Maximum of two integers
fn maxInt(a: int, b: int) -> int {
    if a > b {
        return a
    }
    return b
}

// Minimum of two doubles
fn minDouble(a: double, b: double) -> double {
    if a < b {
        return a
    }
    return b
}

// Maximum of two doubles
fn maxDouble(a: double, b: double) -> double {
    if a > b {
        return a
    }
    return b
}

// Power function for integers (base^exponent)
fn powInt(base: int, exponent: int) -> int {
    if exponent == 0 {
        return 1
    }
    if exponent == 1 {
        return base
    }
    
    var result = 1
    var exp = exponent
    var b = base
    
    loop {
        if exp <= 0 {
            break
        }
        
        let isOdd = exp % 2
        if isOdd == 1 {
            result = result * b
        }
        b = b * b
        exp = exp / 2
    }
    
    return result
}

// Factorial function
fn factorial(n: int) -> int {
    if n <= 1 {
        return 1
    }
    return n * factorial(n - 1)
}

// Fibonacci number at position n
fn fibonacci(n: int) -> int {
    if n <= 1 {
        return n
    }
    var a = 0
    var b = 1
    var i = 2
    loop {
        if i > n {
            break
        }
        let temp = a + b
        a = b
        b = temp
        i = i + 1
    }
    return b
}

// Greatest common divisor (Euclidean algorithm)
fn gcd(a: int, b: int) -> int {
    var x = absInt(a)
    var y = absInt(b)
    
    loop {
        if y == 0 {
            break
        }
        let temp = y
        y = x % y
        x = temp
    }
    
    return x
}

// Least common multiple
fn lcm(a: int, b: int) -> int {
    if a == 0 {
        return 0
    }
    if b == 0 {
        return 0
    }
    let absA = absInt(a)
    let absB = absInt(b)
    return (absA * absB) / gcd(absA, absB)
}

// Check if a number is prime
fn isPrime(n: int) -> bool {
    if n <= 1 {
        return false
    }
    if n <= 3 {
        return true
    }
    
    let mod2 = n % 2
    let mod3 = n % 3
    if mod2 == 0 {
        return false
    }
    if mod3 == 0 {
        return false
    }
    
    var i = 5
    loop {
        let square = i * i
        if square > n {
            break
        }
        
        let modI = n % i
        let modI2 = n % (i + 2)
        if modI == 0 {
            return false
        }
        if modI2 == 0 {
            return false
        }
        i = i + 6
    }
    
    return true
}

// Simple square root approximation using Newton's method
fn sqrtApprox(x: double) -> double {
    if x < 0.0 {
        return 0.0
    }
    if x == 0.0 {
        return 0.0
    }
    
    var guess = x / 2.0
    let epsilon = 0.00001
    
    var i = 0
    loop {
        if i >= 100 {
            break
        }
        
        let nextGuess = (guess + x / guess) / 2.0
        let diff = guess - nextGuess
        let absDiff = diff < 0.0 ? -diff : diff
        
        if absDiff < epsilon {
            return nextGuess
        }
        
        guess = nextGuess
        i = i + 1
    }
    
    return guess
}

// Clamp a value between min and max
fn clampInt(value: int, min: int, max: int) -> int {
    if value < min {
        return min
    }
    if value > max {
        return max
    }
    return value
}

fn clampDouble(value: double, min: double, max: double) -> double {
    if value < min {
        return min
    }
    if value > max {
        return max
    }
    return value
}

// Sign function (-1, 0, or 1)
fn signInt(x: int) -> int {
    if x < 0 {
        return -1
    }
    if x > 0 {
        return 1
    }
    return 0
}

fn signDouble(x: double) -> int {
    if x < 0.0 {
        return -1
    }
    if x > 0.0 {
        return 1
    }
    return 0
}

